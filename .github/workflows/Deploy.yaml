name: Continuous Delivery to EKS

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: read

jobs:
  deploy:
    runs-on: self-hosted

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Set up SSH private key
        env:
          PRIVATE_KEY: ${{ secrets.EC2_KEY }}
          HOSTNAME: ${{ secrets.EC2_HOST }}
          USER_NAME: ${{ secrets.USER_NAME }}
        run: |
          # Save private key to a file
          echo "$PRIVATE_KEY" > private_key && chmod 600 private_key
          
          # SSH into EC2 and execute deployment commands
          ssh -o StrictHostKeyChecking=no -i private_key ${USER_NAME}@${HOSTNAME} '
              # Clone the new repository or update it if it already exists
              cd /home/ubuntu || exit
              if [ ! -d "Ironhack_Project2" ]; then
                  git clone https://github.com/NavinE360/Ironhack_Project2.git
              fi
              cd Ironhack_Project2 &&
              git checkout dev &&
              git fetch --all &&
              git reset --hard origin/dev &&
              git pull origin dev &&
              sudo npm install &&
              sudo npm run build &&
              sudo pm2 stop ./dist/index.js || true &&
              sudo pm2 start ./dist/index.js
          '

      - name: Update kubeconfig for EKS
        run: |
          set -x
          aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name ${{ secrets.EKS_CLUSTER_NAME }}

      - name: Apply Database Deployment and Service
        run: |
          set -x
          kubectl apply -f k8s/db-deploy.yaml
          kubectl get pods -l app=database --output wide

      - name: Apply Backend Deployment and Service
        run: |
          set -x
          kubectl apply -f k8s/backend-deploy.yaml
          kubectl get pods -l app=api --output wide

      - name: Apply Frontend Deployment and Service
        run: |
          set -x
          kubectl apply -f k8s/frontend-deploy.yaml
          kubectl get pods -l app=ui --output wide

      - name: Verify Backend Service is Running
        run: |
          set -x
          kubectl rollout status deployment/backend-deployment
          kubectl get pods -l app=api

      - name: Verify Frontend Service is Running
        run: |
          set -x
          kubectl rollout status deployment/frontend-deployment
          kubectl get pods -l app=ui

      - name: Verify Database Service is Running
        run: |
          set -x
          kubectl rollout status deployment/postgres-deployment
          kubectl get pods -l app=database

      - name: Verify Application is Accessible
        run: |
          set -x
          FRONTEND_IP=$(kubectl get svc frontend-service -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          echo "Frontend is accessible at: http://$FRONTEND_IP"
